#!/usr/local/bin/luajit

--- huectl: Command line utility to control Hue lights
--
-- The tool uses the Lua Hue API by the same author.
--
-- Copyright Pete Kazmier 2013

local hue = require 'hue'
local json = require 'json'
local lapp = require 'pl.lapp'
local utils = require 'pl.utils'
local pretty = require 'pl.pretty'
local tablex = require 'pl.tablex'

local args = lapp [[
Utility to control Philips Hue lights
  -d,--discover                         Discover local bridges
  -r,--register   (optional string)     Register username at bridge
  -u,--username   (default huectladmin) Authenticate using this username
  -l,--list                             Lights to manipulate
  -g,--get        (optional string)     Get an attribute (state.on, state.bri)

  -O,--on  (optional true|false)        Turn lights on or off
  -A,--alert  (optional select|lselect) Cycle the light brightness
  -E,--effect (optional none|colorloop) Set an effect 
  -T,--transitiontime (optional number) Set transition time (x100ms)

  -B,--bri (optional 0..255)     Set brightness (0 low, 255 high)
  -H,--hue (optional 0..65535)   Set hue (0 red, 25500 green, 46920 blue)
  -S,--sat (optional 0..255)     Set saturation (0 colored, 255 white)
  -C,--ct  (optional 153..500)   Set color temp (153 cooler, 500 warmer)

  <bridge>        (optional string)     IP address of a Philips bridge
  <lights...>     (optional string)     List of lights (id or name)
]]

if args.discover then
   for _,ip in ipairs(hue.discover()) do
      print(ip)
   end
   os.exit(0)
end

if args.register then
   print('Not implemented yet '..args.register)
   os.exit(0)
end

if not args.bridge then
   lapp.error('missing bridge parameter')
end

local b = hue.Bridge:new(args.bridge, args.username)

if args.list then
   local f = function(x,y) return tonumber(x) < tonumber(y) end
   for k,v in tablex.sort(b:lights(),f) do
      print(k,v)
   end
   os.exit(0)
end

local arg_formatters = {
   on = function(x) return x=='true' and true or false end,
   ct = math.floor,
   bri = math.floor,
   hue = math.floor,
   sat = math.floor,
   alert = function(x) return x end,
   effect = function(x) return x end,
   transitiontime = math.floor,
}

local state = {}
for arg,formatter in pairs(arg_formatters) do
   if args[arg] then
      state[arg] = arg_formatters[arg](args[arg])
   end
end

if next(state) ~= nil then
   local retval = 0
   local status = b:set_state(args.lights, state)
   for light,results in pairs(status) do
      for _,result in ipairs(results) do
         if result.error then
            retval = 1
            print(light, result.error.description)
         end
      end
   end
   os.exit(retval)
end

pretty.dump(b:get_state(args.lights, args.get))
os.exit(0)
